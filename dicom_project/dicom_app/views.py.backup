import pydicom
from django.shortcuts import render
from django.db.models import Q
from django.urls import reverse_lazy
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView
from django.http import FileResponse, Http404
from django.shortcuts import get_object_or_404, redirect
from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
import os
import traceback
import shutil
import tempfile
from pathlib import Path
from dicom2nifti import convert_directory
import json
import zipfile
from .models import DicomFile, DicomTag, Experiment, Participant
from .forms import DicomFileForm, DicomTagForm, DicomUploadForm
import tempfile
import numpy as np
import nibabel as nib
import uuid

def generate_pacient_code():
    # Genera un UUID4 y toma los primeros 8 caracteres en mayúsculas
    return str(uuid.uuid4())[:8].upper()

def anonymize_dicom(ds):
    """
    Función para anonimizar un archivo DICOM eliminando o modificando datos sensibles.

     Aplica técnicas de anonimización al archivo DICOM:
    1. Pseudonimización: Reemplaza valores sensibles por identificadores anónimos.
    2. Enmascaramiento de datos: Sustituye información con valores genéricos.
    3. Eliminación de datos sensibles: Borra etiquetas privadas y secundarias.
    """
    # Lista de elementos sensibles a anonimizar
    sensitive_tags = [
        "PatientName", "PatientID", "PatientBirthDate", "PatientSex",
        "InstitutionName", "ReferringPhysicianName", "StudyInstanceUID",
        "SeriesInstanceUID", "AccessionNumber"
    ]

    # Eliminar datos sensibles
    for tag in sensitive_tags:
        if tag in ds:
            ds.data_element(tag).value = ""

    # Reemplazar identificadores únicos
    ds.StudyInstanceUID = pydicom.uid.generate_uid()
    ds.SeriesInstanceUID = pydicom.uid.generate_uid()
    ds.SOPInstanceUID = pydicom.uid.generate_uid()

    # Pseudonimización: Sustitución de datos personales con valores anónimos
    def person_names_callback(ds, elem):
        if elem.VR == "PN":  # PN = Personal Name
            elem.value = "anonymous"

    ds.walk(person_names_callback)

    # Eliminación de datos sensibles
    ds.remove_private_tags()

    def curves_callback(ds, elem):
        if elem.tag.group & 0xFF00 == 0x5000:
            del ds[elem.tag]

    ds.walk(curves_callback)

    # Enmascaramiento de datos: Se reemplazan con valores genéricos en lugar de eliminarlos
    if "PatientBirthDate" in ds:
        ds.data_element("PatientBirthDate").value = "19000101"

    return ds


def upload_dicom(request):
    if request.method == 'POST':
        form = DicomUploadForm(request.POST, request.FILES)
        if form.is_valid():
            dicom_file = request.FILES['dicom_file']
            ds = pydicom.dcmread(dicom_file)

            # Aplicar anonimización antes de guardar los datos
            ds = anonymize_dicom(ds)

            # Generar nombre único y ruta permanente
            pacient_code = generate_pacient_code()
            save_dir = Path("media/dicoms/")
            save_dir.mkdir(parents=True, exist_ok=True)
            filename = f"{pacient_code}_{uuid.uuid4().hex[:6]}.dcm"
            full_path = save_dir / filename

            # Guardar el archivo anonimizado
            ds.save_as(str(full_path))

            # Crear instancia DicomFile con ruta al archivo
            dicom_instance = DicomFile.objects.create(
                patient_name=pacient_code,
                file=str(full_path)
            )

            dicom_data = []  # Para almacenar los datos del DICOM que vamos a mostrar

            # Guardar los tags anonimizados en la base de datos
            for element in ds:
                dicom_entry = DicomTag.objects.create(
                    dicom_file=dicom_instance,
                    tag=str(element.tag),
                    description=element.description(),
                    vr=element.VR,
                    value=str(element.value)
                )
                dicom_data.append({
                    'tag': dicom_entry.tag,
                    'description': dicom_entry.description,
                    'vr': dicom_entry.vr,
                    'value': dicom_entry.value,
                })

            # Pasar los datos DICOM anonimizados a la plantilla de éxito
            return render(request, 'success.html', {'dicom_data': dicom_data, 'patient_name': pacient_code})


    else:
        form = DicomUploadForm()

    return render(request, 'upload.html', {'form': form})

class DicomFileListView(ListView):
    model = DicomFile
    template_name = 'dicomfile_list.html'  # Nombre de tu plantilla
    context_object_name = 'dicom_files'
    paginate_by = 10  # Número de resultados por página

    def get_queryset(self):
        queryset = super().get_queryset()
        query = self.request.GET.get('q')
        if query:
            queryset = queryset.filter(Q(patient_name__icontains=query))
        return queryset

class DicomFileDetailView(DetailView):
    model = DicomFile
    template_name = 'dicomfile_detail.html'  # Plantilla que mostrarás
    context_object_name = 'dicom_file'  # Nombre del contexto en la plantilla

class DicomFileCreateView(CreateView):
    model = DicomFile
    form_class = DicomFileForm
    template_name = 'dicomfile_form.html'
    success_url = reverse_lazy('dicomfile_list')

class DicomFileUpdateView(UpdateView):
    model = DicomFile
    form_class = DicomFileForm
    template_name = 'dicomfile_form.html'
    success_url = reverse_lazy('dicomfile_list')

class DicomFileDeleteView(DeleteView):
    model = DicomFile
    template_name = 'dicomfile_confirm_delete.html'
    success_url = reverse_lazy('dicomfile_list')

def convert_single_dicom_to_nifti(dicom_path, output_path):
    ds = pydicom.dcmread(dicom_path)
    if "PixelData" not in ds:
        raise Exception("DICOM no contiene datos de imagen (PixelData)")

    image = ds.pixel_array
    if image.ndim < 2:
        raise Exception("La imagen es inválida o vacía.")

    affine = np.eye(4)
    nii = nib.Nifti1Image(image, affine)
    nib.save(nii, output_path)

def export_dicom_to_bids(request, pk):
    dicom_instance = get_object_or_404(DicomFile, pk=pk)
    dicom_path = dicom_instance.file

    if not os.path.exists(dicom_path):
        raise Http404("Archivo DICOM no encontrado")

    temp_dir = tempfile.mkdtemp()
    subject_id = f"sub-{dicom_instance.patient_name.lower()}"
    session_id = "ses-01"
    anat_dir = Path(temp_dir) / subject_id / session_id / "anat"
    anat_dir.mkdir(parents=True, exist_ok=True)

    output_nifti = anat_dir / 'output.nii.gz'
    try:
        # Crear carpeta temporal con el único DICOM
        temp_dicom_dir = tempfile.mkdtemp()
        temp_dicom_path = os.path.join(temp_dicom_dir, 'image.dcm')
        shutil.copyfile(dicom_path, temp_dicom_path)
        convert_directory(temp_dicom_dir, anat_dir, compression=True)
    except Exception as e:
        print("❌ dicom2nifti falló:", str(e))

    # Si aún no se generó ningún NIfTI, usar método alternativo
    nii_files = list(anat_dir.glob("*.nii.gz"))
    if not nii_files:
        try:
            convert_single_dicom_to_nifti(dicom_path, output_nifti)
            nii_files = [output_nifti]
        except Exception as e:
            traceback.print_exc()
            return HttpResponse(f"No se pudo convertir el DICOM: {e}", status=500)

    if not nii_files:
        return HttpResponse("❌ La conversión falló: no se generó ningún archivo .nii.gz", status=500)

    output_nifti = nii_files[0]

    # Crear JSON de metadatos
    metadata = {
        "Modality": "MRI",
        "Manufacturer": "Unknown",
        "PatientName": dicom_instance.patient_name,
        "InstitutionName": "Anonymous Hospital"
    }

    try:
        json_path = output_nifti.with_suffix(".json")
        with open(json_path, 'w') as jf:
            json.dump(metadata, jf, indent=4)
    except Exception as e:
        return HttpResponse(f"No se pudo crear el archivo JSON: {e}", status=500)

    with open(Path(temp_dir) / "dataset_description.json", 'w') as df:
        json.dump({
            "Name": "Exported BIDS Dataset",
            "BIDSVersion": "1.8.0"
        }, df, indent=4)

    # Comprimir todo
    zip_path = tempfile.NamedTemporaryFile(delete=False, suffix=".zip").name
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(temp_dir):
            for file in files:
                full_path = os.path.join(root, file)
    # Reemplazar identificadores únicos
    ds.StudyInstanceUID = pydicom.uid.generate_uid()
    ds.SeriesInstanceUID = pydicom.uid.generate_uid()
    ds.SOPInstanceUID = pydicom.uid.generate_uid()

    # Pseudonimización: Sustitución de datos personales con valores anónimos
    def person_names_callback(ds, elem):
        if elem.VR == "PN":  # PN = Personal Name
            elem.value = "anonymous"

    ds.walk(person_names_callback)

    # Eliminación de datos sensibles
    ds.remove_private_tags()

    def curves_callback(ds, elem):
        if elem.tag.group & 0xFF00 == 0x5000:
            del ds[elem.tag]

    ds.walk(curves_callback)

    # Enmascaramiento de datos: Se reemplazan con valores genéricos en lugar de eliminarlos
    if "PatientBirthDate" in ds:
        ds.data_element("PatientBirthDate").value = "19000101"

    return ds


def upload_dicom(request):
    if request.method == 'POST':
        form = DicomUploadForm(request.POST, request.FILES)
        if form.is_valid():
            dicom_file = request.FILES['dicom_file']
            ds = pydicom.dcmread(dicom_file)

            # Aplicar anonimización antes de guardar los datos
            ds = anonymize_dicom(ds)

            # Generar nombre único y ruta permanente
            pacient_code = generate_pacient_code()
            save_dir = Path("media/dicoms/")
            save_dir.mkdir(parents=True, exist_ok=True)
            filename = f"{pacient_code}_{uuid.uuid4().hex[:6]}.dcm"
            full_path = save_dir / filename

            # Guardar el archivo anonimizado
            ds.save_as(str(full_path))

            # Crear instancia DicomFile con ruta al archivo
            dicom_instance = DicomFile.objects.create(
                patient_name=pacient_code,
                file=str(full_path)
            )

            dicom_data = []  # Para almacenar los datos del DICOM que vamos a mostrar

            # Guardar los tags anonimizados en la base de datos
            for element in ds:
                dicom_entry = DicomTag.objects.create(
                    dicom_file=dicom_instance,
                    tag=str(element.tag),
                    description=element.description(),
                    vr=element.VR,
                    value=str(element.value)
                )
                dicom_data.append({
                    'tag': dicom_entry.tag,
                    'description': dicom_entry.description,
                    'vr': dicom_entry.vr,
                    'value': dicom_entry.value,
                })

            # Pasar los datos DICOM anonimizados a la plantilla de éxito
            return render(request, 'success.html', {'dicom_data': dicom_data, 'patient_name': pacient_code})


    else:
        form = DicomUploadForm()

    return render(request, 'upload.html', {'form': form})

class DicomFileListView(ListView):
    model = DicomFile
    template_name = 'dicomfile_list.html'  # Nombre de tu plantilla
    context_object_name = 'dicom_files'
    paginate_by = 10  # Número de resultados por página

    def get_queryset(self):
        queryset = super().get_queryset()
        query = self.request.GET.get('q')
        if query:
            queryset = queryset.filter(Q(patient_name__icontains=query))
        return queryset

class DicomFileDetailView(DetailView):
    model = DicomFile
    template_name = 'dicomfile_detail.html'  # Plantilla que mostrarás
    context_object_name = 'dicom_file'  # Nombre del contexto en la plantilla

class DicomFileCreateView(CreateView):
    model = DicomFile
    form_class = DicomFileForm
    template_name = 'dicomfile_form.html'
    success_url = reverse_lazy('dicomfile_list')

class DicomFileUpdateView(UpdateView):
    model = DicomFile
    form_class = DicomFileForm
    template_name = 'dicomfile_form.html'
    success_url = reverse_lazy('dicomfile_list')

class DicomFileDeleteView(DeleteView):
    model = DicomFile
    template_name = 'dicomfile_confirm_delete.html'
    success_url = reverse_lazy('dicomfile_list')

def convert_single_dicom_to_nifti(dicom_path, output_path):
    ds = pydicom.dcmread(dicom_path)
    if "PixelData" not in ds:
        raise Exception("DICOM no contiene datos de imagen (PixelData)")

    image = ds.pixel_array
    if image.ndim < 2:
        raise Exception("La imagen es inválida o vacía.")

    affine = np.eye(4)
    nii = nib.Nifti1Image(image, affine)
    nib.save(nii, output_path)

def export_dicom_to_bids(request, pk):
    dicom_instance = get_object_or_404(DicomFile, pk=pk)
    dicom_path = dicom_instance.file

    if not os.path.exists(dicom_path):
        raise Http404("Archivo DICOM no encontrado")

    temp_dir = tempfile.mkdtemp()
    subject_id = f"sub-{dicom_instance.patient_name.lower()}"
    session_id = "ses-01"
    anat_dir = Path(temp_dir) / subject_id / session_id / "anat"
    anat_dir.mkdir(parents=True, exist_ok=True)

    output_nifti = anat_dir / 'output.nii.gz'
    try:
        # Crear carpeta temporal con el único DICOM
        temp_dicom_dir = tempfile.mkdtemp()
        temp_dicom_path = os.path.join(temp_dicom_dir, 'image.dcm')
        shutil.copyfile(dicom_path, temp_dicom_path)
        convert_directory(temp_dicom_dir, anat_dir, compression=True)
    except Exception as e:
        print("❌ dicom2nifti falló:", str(e))

    # Si aún no se generó ningún NIfTI, usar método alternativo
    nii_files = list(anat_dir.glob("*.nii.gz"))
    if not nii_files:
        try:
            convert_single_dicom_to_nifti(dicom_path, output_nifti)
            nii_files = [output_nifti]
        except Exception as e:
            traceback.print_exc()
            return HttpResponse(f"No se pudo convertir el DICOM: {e}", status=500)

    if not nii_files:
        return HttpResponse("❌ La conversión falló: no se generó ningún archivo .nii.gz", status=500)

    output_nifti = nii_files[0]

    # Crear JSON de metadatos
    metadata = {
        "Modality": "MRI",
    return render(request, 'main_menu.html')

# New views for file uploads
@login_required
def upload_consent_note(request, participant_id):
    """Vista para subir nota de consentimiento de un participante"""
    participant = get_object_or_404(Participant, pk=participant_id)
    
    if request.method == 'POST':
        if 'consent_file' in request.FILES:
            file = request.FILES['consent_file']
            # TODO: Guardar archivo de consentimiento
            # participant.consent_note = file
            # participant.save()
            return redirect('upload_success', upload_type='consent')
    
    return render(request, 'dicom_app/upload_consent_note.html', {
        'participant': participant
    })

@login_required
def upload_participant_dicom(request, participant_id):
    """Vista para subir archivos DICOM de un participante"""
    participant = get_object_or_404(Participant, pk=participant_id)
    
    if request.method == 'POST':
        if 'dicom_files' in request.FILES:
            files = request.FILES.getlist('dicom_files')
            # Procesar múltiples archivos DICOM
            for dicom_file in files:
                ds = pydicom.dcmread(dicom_file)
                ds = anonymize_dicom(ds)
                
                # Generar nombre único y guardar
                pacient_code = participant.subject_id
                save_dir = Path(f"media/dicoms/{participant.experiment.id}/{participant.id}/")
                save_dir.mkdir(parents=True, exist_ok=True)
                filename = f"{pacient_code}_{uuid.uuid4().hex[:6]}.dcm"
                full_path = save_dir / filename
                
                ds.save_as(str(full_path))
                
                # Crear instancia DicomFile
                DicomFile.objects.create(
                    patient_name=pacient_code,
                    file=str(full_path)
                )
            
            return redirect('upload_success', upload_type='dicom')
    
    return render(request, 'dicom_app/upload_dicom.html', {
        'participant': participant
    })

@login_required
def upload_success(request, upload_type):
    """Vista de éxito después de subir archivos"""
    messages = {
        'dicom': '¡Archivo DICOM subido exitosamente!',
        'consent': '¡Nota de consentimiento subida exitosamente!'
    }
    message = messages.get(upload_type, '¡Archivo subido exitosamente!')
    
    return render(request, 'dicom_app/upload_success.html', {
        'message': message
    })